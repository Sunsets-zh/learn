#include<stdio.h>
int main()
{
	int i=5;
	/*int *const q = &i;
	printf("*q=%d\n", *q);
	*q = 25;
	printf("*q=%d\n", *q);*/
	//q++;因为int *const q相当于锁死了q的地址，可以操作地址里的数据，但是不能操作q；


	//=======================================================================================
	//	=====================================================================================


	//const int *m = &i;
	//*m = 25;因为const int*m相当于锁死了地址里的数，这种情况下可以操作地址，但是不能操作空间里的内容；
	//m++;
	//printf("*m=%d\n", *m);
	//printf("m=%p\n", p);

	int const *n = &i;
	//*n = 25;int const *n相当于const int *n，都是锁死了地址里的内容；
	*n++;
	const int a[] = { 1,2,3,4,5,6, };
			//数组指针本身就是const类型，这儿添加的const是表明数组里的每一个int变量都是const类型
			//所以无法在后期更改值，必须进行初始化；
		//数组传输的是一个地址，所以函数内部可以通过指针来修改数组内部的值，
		//为了数组数据不被修改，一种是使用 const int a[]，另一种是；
		//int sum(const int a[],int length),这种方式外部 定义int a[]即可，多了一些灵活性

	return 0;
	/*eg.void （const int*q）
			int a=15;
			f(&a);
			const int b=a;
			void保证在函数内部不会修改q地址里放的值，并非必须传入一个const值，像&a，并不是一个const值
			但传入函数后，const 数据不会被修改
			f(&b);这是可以的，b是一个const
			b=a+1;		这是不可以的，因为b是一个const值
			====================
			适用于：当要传递一个比地址大的数据时，用传递一个指针的方式来传递（因为指针是一个地址
			，所以不会越界），而且可以规避函数对于外部数据的修改
			类似于数组，数组很大，但是我们只传递一个地址过去就很轻松*/


}